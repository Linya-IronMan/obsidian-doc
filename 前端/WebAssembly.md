#读书笔记

《WebAssembly 实战》

- [ ] #task 复习 WASM 核心原理，并整理一份思维导图
- [ ] #task 使用 rust 完成一个 WASM 模块



# 第一章：初识 WebAssembly
- 是什么
- 能解决什么问题
- 工作原理
- 安全性来自何处
- 哪些语言可以用于创建WebAssembly

## 1.1 asm.js

Mozilla（Firefox 浏览器开发者）定义了一个名为 asm.js 的 JavaScript 子集， 这是 WASM 的先驱

- 并不会直接编写 asm.js 而是通过 C 或 C++ 编写逻辑，然后将其转换为 JavaScript
- 当浏览器的 JavaScript 引擎看到名为 asm pragma 语句的特殊字符串（“use asm”）时，会告诉浏览器它可以使用底层系统调用而不是更昂贵的 JavaScript 操作

## 解决的问题

### 性能改进

解决的是代码的下载时间到代码的执行速度

JavaScript 是一种解释型编程语言，会在执行时读入编写的代码，并将这些指令及时翻译成机器码。

使用解释型语言的时候，不需要提前变异代码，意味着启动的速度更快。缺点是， 解释器需要每次运行代码时将指令转换成机器码

浏览器厂商引入了一种 JIT（just-in-time）即时编译的概念，让 JavaScript 引擎在运行时检测代码。如果有一部分代码被使用的次数足够多，那么引擎就会试图将这一部分编译为机器码，这样它就可以绕过JavaScript 引擎转而使用底层系统方法，这要快得多。

这种方法不仅可以获得解释器的优点，代码被调用时能够尽快被启动，而且拥有执行时能更快速运行的代码。

JavaScript 引擎需要监测代码多次才能将其编译为机器码, 因为 JavaScript 也是一种动态编程语言。在 JavaScript 中,一个变量可以持有任何类型的值。举例来说,一个变量可能在最初持有一个整型值, 但之后被赋予一个字符串。 代码运行若干次之后, 浏览器才能了解应该预期什么 (类型) 。即使是在编译后,也仍然需要监测这段代码,因为某些条件可能会改变,此时需要抛弃这部分编译后的代码,重新开始整个处理过程。


### 比 JavaScript 更快的启动速度
```ad-note
和 asm.js 一样，WASM 并不是设计用于手动编写的，也不是供人类阅读的。
```

代码被编译为 WebAssembly 之后，字节码会以二进制格式而不是文本格式表示，这可以减小文件大小，从而支持快速传输和下载。


上面提到的 JIT 方案，需要代码多次执行之后才能将其编译为机器码。而 WASM 代码是静态类型的，可以与之变量持有的值的类型。所以 WASM 代码可以从一开始就编译为机器码，无需先检测，因此第一次运行代码就可以看到性能提升

存在一种叫做**流编译** 的技术，在浏览器下载和接受文件时，此技术可以将 WASM 代码编译为机器码。支持 WASM 下载完毕即进行初始化，会显著加速模块的启动过程

### 可以在浏览器中使用 JavaScript 之外的语言

WASM 从一开始就被设计为编译目标，所以其他语言无需转换成 JavaScript 即可进行 Web 开发。


## WebAssembly 工作原理

JavaScript 变量是动态的，所以在执行之前（编译的时候），所处理的变量为何种类型并不是显而易见的。

确定类型的唯一方法就是在代码执行的时候进行检测，这也正是 JavaScript 引擎所做的。一旦获得了这些变量的类型，引擎就可以将这段代码转换为机器码。

```ad-note
1. 即使是 JS 引擎，也需要在代码执行的时候才能确定变量的类型
2. 引擎将代码转换为机器码的前提是需要得知变量的类型
```

开发者使用更接近人类语言的语言编写代码，但是计算机处理器只能理解机器语言。因此，编写的代码必须转化为机器码才能运行。需要注意的是，每一类计算机处理器都有它自己的机器码类型

```ad-key
每一类计算机处理器都有它自己的机器码类型。编译的时候，根据机器类型编译成不同的机器码
```

---

一般的语言编译过程，并不是将每种编译语言啊都直接编译为机器码的各个版本，那么半效率会很低。取而代之的是，编译器中称为 **前端** 的部分会将所编写的代码编译为一种中间表示（Intermediate representation ， IR）。创建好 IR 代码后，编译器的后端部分会接受 IR 代码，对其进行优化，然后将其转换为所需要的机器码。

浏览器可以在不同的处理器（桌面计算机，智能手机，平板设备）上运行，因此为每个可能的处理器发布一个 WASM 代码的编译后版本会非常繁复。

```ad-tip
WASM 是需要支持多种语言编译成 wasm 这个操作的。为每个语言都要添加一种 wasm 的编译方式，是非常繁复的，所以从 IR 开始。IR 是所有语言都会编译生成的一种中间语法，将他编译成 wasm 就会简单很多，并且之后浏览器将 wasm 编译成机器码的过程并不会更加复杂。
```

![](assets/Pasted%20image%2020220503220625.png)

wasm 文件中的字节码还不是机器码，它只是支持 wasm 的浏览器能够理解的一组虚拟指令。之后，当 `.wasm` 文件被加载到浏览器中时，浏览器会验证这个文件的合法性，然后这些字节码会继续编译为浏览器所运行的设备上的机器码。

浏览器将 WASM 字节码编译为机器码之后，就可以将编译后的模块传送给一个 **Web Worker**， 或另一个**浏览器窗口**。设置可以利用这个编译后的模块创建这个模块的更多实例。

编译后 wasm 文件还需要进行 **实例化** 才能使用。

**实例化的过程**
1. 接受需要的所有导入对象
2. 初始化模块元素
3. 如果定义了启动函数，还需要调用启动函数
4. 最后向执行环境返回一个模块实例


## 1.4 WebAssembly 模块的结构

WASM 程序的主要单元称为模块， 既用来表示代码的二进制版本，也表示浏览器中的编译后版本。

![](assets/Pasted%20image%2020220503221519.png)

- 前导
	- 幻数（magic number）：用于区分 WASM 模块与 ES6 模块
	- 版本号：指明创建本文件时使用的 WASM 二进制格式版本
- 已知段：只能被包含一次，并且要按照特定顺序出现。进行模块初始化时会检验其有效性
- 自定义段：为用户提供的在模块内包含数据的一种方法，应用于已知段不适用的情况。
	- 可以出现在模块任意位置，任意多次，多个自定义段之间甚至可以复用一个名字
	- 并不会触发验证错误。
	- 框架可以惰性加载自定义段，包含的数据可能知道模块初始化到某个阶段才有效
	- name：WASM 可以有一个调试版本，在调试时这个段持有文本形式的函数和变量名。
		- 此段只出现一次，并且只出现在 Data 段之后

## 1.5 WebAssembly 文本格式


- [ ] #todo WASM 的  `s-表达式` 的文本格式是什么？


这个文本格式允许浏览器中的代码支持 `View Source` ，也可以用于调试。设置可以手动编写 s-表达式，然后用专门的编译器将代码编译为 WASM 二进制格式。

选择 View Source 以及用于调试目的时浏览器会使用 WASM 的文本格式。

> 如果要将 s-表达式(module)编译为 WebAssembly 二进制格式,并观察得到的二进制值,那么这个文件会只包含前导字节:0061 736d(幻数)和 0100 0000(版本号) 。


## 1.6 WebAssembly 如何获得安全性

1. 它是第一个共享 JavaScript VM 的语言，而 JavaScript VM 在运行时是沙箱化的
2. WASM 的可访问范围不超过 JavaScript 的访问范围，并且遵守同样的安全性规则，包括同源策略
3. WASM 对于设备内存没有直接访问权限，而是运行时环境在初始化过程中向模块传递一个 ArrayBuffer。模块将这个 ArrayBuffer 当做线性内存来使用，WASM 框架执行检查以确保代码不会对这个数组进行越界操作。
4. 像函数指针这样存储在 Table 段中的项目，WASM 也不能直接访问。代码会用索引值向 WASM 框架提出访问某个项目的请求。然后框架访问内存，并代表代码执行这个项目。

```ad-note
1. WASM 框架会监督代码的执行规范。包括访问范围不超过 JS；内存越界操作检测；
```

```ad-question
为什么函数指针要存储在 Table 段中？
```



